<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>스무고개 방</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">
  <style>

      #container {
          height: 98vh;
      }

      #headerContainer {
          min-height: 17%;
      }

      #contentContainer {
          height: 83%;
      }

      .container hr {
          margin: 0.5rem;
      }

      #roomHeader, #roomInfo {
          text-indent: 15px;
      }

      #twentyTutorialModalBtn {
          position: absolute;
          right: 15px;
          top: 0px;
      }

      #roomHeader {
          margin-top: 10px;
      }

      #roomInfo span {
          margin-right: 10px;
      }

      #menuContainer {
          /*margin: 20px auto;*/
          position: relative;
      }

      #sendGptMessageBtn {
          display: none;
      }

      #sendMessageBtn {
          margin: 0 5px;
      }

      #unReadyBtn {
          display: none;
      }

      #inputStatus {
          margin-bottom: 5px;
      }

      .input-status-dead {
          color: red;
      }

      #conversationBox {
          margin-bottom: 10px;
          height: 88%;
          overflow: hidden;
          overflow-y: scroll;
      }

      .member-connected {
          color: green;
      }

      .member-disconnected {
          color: grey;
      }

      .member-list-item span {
          margin-right: 15px;
          font-size: 1.2em;
      }

      .member-list-item-header {
          margin-bottom: 7px;
      }

      #conversationWrapper {
          padding: 0;
      }

      .conversation-list-item {
          /*background-color: white;*/
          /*border-style: solid;*/
          /*border-width: medium;*/
          border-bottom: none;
      }

      .conversation-list-item-body {
          padding: 10px;
          border-radius: 10px;
      }

      .conversation-list-item-username {

      }

      .conversation-list-item-content {

      }

      .twenty-game-ask-conversation .conversation-list-item-content {
          font-weight: bold;
      }

      .twenty-game-from-gpt-conversation .conversation-list-item-content {
          font-weight: bold;
      }

      .conversation-list-item-created-at {
          font-size: 0.8em;
      }

      .twenty-game-ask-conversation, .twenty-game-from-gpt-conversation {
          border-left: red solid 3px;
      }

      /*.twenty-game-from-gpt-conversation {*/
      /*    border-bottom: green solid 4px;*/
      /*}*/

      .myConversation {
          /*background-color: lightblue;*/
      }

      .otherConversation {
          background-color: whitesmoke;
      }

      .gptConversation {
          /*background-color: lightgreen;*/
      }

      .systemConversation {
          background-color: ghostwhite;
      }

      .twenty-asking-conversation-input {
          border: green solid 3px;
          border-radius: 5px;
      }

      .ban-member-button {
          padding-top: 0.2em;
          padding-bottom: 0.2em;
          vertical-align: text-bottom;
          line-height: 100%;
      }


  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.4.0/sockjs.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
  <script type="text/javascript" th:inline="javascript">

      /*<![CDATA[*/
      let thCurrentMember = [[${currentMember}]];
      let thCurrentRoom = [[${chatRoom}]];
      /*]]>*/
      // console.log("thCurrentMember = {}", thCurrentMember);
      // console.log("thCurrentRoom = {}", thCurrentRoom);

      // STOMP 변수
      let stompClient = null;
      let currentSubscription = null;

      // 서버에서 내려주는 TwentyMessageDto 구조. (사용X)
      const TwentyMessageDto = {
          roomId: 0,
          userId: 0,
          type: '',
          username: '',
          content: '',
          createdAt: '',
          isGptChat: false,       // Gpt 와의 대화인지 여부, 프론트에서 전달

          gptUuid: null,            // GPT 의 UUID, UUID(8)
          isTwentyStart: false,    // 시작시, 시작성공여부
          order: 0,                // 진행 시, user 자신의 순서
          nextUserId: 0,         // 진행 시, gpt 가 내려주는 다음 순서 userId
          twentyWinner: '',          //  종료 시, 승자의 username
          twentyDeadUserId: 0,    // 오답시 오답자의 id
      }

      // syncMemberList 에서 사용하는 MemberUserDto 구조
      const MemberUserDto = {
          // from Member
          roomId: 0,
          userIdL: 0,
          isRoomConnected: false,
          isRoomOwner: false,
          isGptOwner: false,
          isTwentyGameReady: false,
          // from User
          username: false,
      }


      document.addEventListener('DOMContentLoaded', function () {

          // DOM 요소 탐색
          let usernameInput = document.getElementById('usernameInput');
          let contentInput = document.getElementById('contentInput');
          let roomInfo = document.getElementById('roomInfo');

          let infoIsPlaying = document.getElementById('infoIsPlaying');

          let conversationInput = document.getElementById('conversationInput');
          let conversationList = document.getElementById('conversationList');
          let conversationBox = document.getElementById('conversationBox');
          let conversationWrapper = document.getElementById('conversationWrapper');

          let memberList = document.getElementById('memberList');

          // 이벤트 리스터용 DOM 요소 탐색
          let memberListBtn = document.getElementById('memberListBtn');
          let sendMessageBtn = document.getElementById('sendMessageBtn');
          let sendGptMessageBtn = document.getElementById('sendGptMessageBtn');
          let unSubscribeBtn = document.getElementById('unSubscribeBtn');
          let startBtn = document.getElementById('startBtn');
          let readyBtn = document.getElementById('readyBtn');
          let unReadyBtn = document.getElementById('unReadyBtn');
          let inputStatus = document.getElementById('inputStatus');

          // connect connectInit()
          let sendUrl = '';
          let subUrl = '';
          let currentRoomId = '';
          let currentUserId = '';
          let currentUsername = '';

          // thCurrentMember 로 초기화할 변수 (갱신되지 않는 변수들)
          // thCurrentMember 는 방장이 아닌 일반유저의 경우, 방 첫 입장때 null 이다.
          let isCurrentUserRoomOwner =
              thCurrentMember ? thCurrentMember.isRoomOwner : false; // 내가 방장인지 여부
          // console.log("isCurrentUserRoomOwner = {}", isCurrentUserRoomOwner);

          // 필요시 초기화될 변수
          let responseMemberList = null; // 서버에서 받아온 멤버리스트, syncMemberList 와 initMemberList 에서 갱신

          let readyUserCount = 0;
          let allUserCount = 0;
          let isCurrentUserReady = false;
          let isTwentyStart = false; // 서버에서 스무고개 시작 여부 확인후 전송됨

          let playerInfoList = null; // START 에서 갱신할 플레이어 정보 리스트 (순서, alive 여부 들어있음)
          let myTwentyOrder = -1; // 스무고개 순서 (TWENTY_GAME_START 메시지 오면 갱신)
          let nextUserId = 0; // 서버에서 받은 현재순서 userId, TWENTY_FROM_GPT 에서 갱신

          let currentGptUuid; // 스무고개 START 하면 서버에서 uuid 받아서 초기화

          let twentyWinner;

          let currentQuestionCount = 0; // 메시지에 표시하기위해 작성됨
          let alivePlayerCount = 0; // START 에서 readyUserCount 대입 후, 오답자가 나올때 마다 --
          let deadPlayerCount = 0; // 오답자가 나올때마다 ++, 내차례때 해당 값으로 alivePlayerCount 갱신(감소) 후 0으로 재초기화.
          let remainingOrderCount; // 내 차례까지 남은 횟수.
          // 내 첫차례 전 : myTwentyOrder - elapsedTurn
          // 내 첫차례 후 : aliveUserCount - 1 - elapsedTurn
          // 플레이어가 죽고나서, 내 차례가 되기 전에는 aliveUserCount 를 갱신하지 않아야 한다. (오답자와 남은사람수 관련 X)

          let elapsedTurn = 0; // 지난 턴 갯수
          let isMyFirstTurnElapsed = false; // 내가 첫 턴을 지났는지 여부. 내 첫 턴이 지났나에 따라 계산이 다름

          let isPlaying = false; // 게임중인지 여부. TWENTY_GAME_START, TWENTY_GAME_END 에서 갱신, sync 에서 사용

          let isCurrentUserDead = false; // 내가 오답자인지 여부. TWENTY_FROM_GPT 에서 갱신

          let banUserId = 0; // 밴할 유저 id


          // 초기 Connect 호출
          connect();

          // eventListener =====================================================================================

          window.addEventListener("beforeunload", function (event) {
              disconnect();
          });

          sendMessageBtn.addEventListener('click', sendMessage.bind(null, 'CHAT'));
          sendGptMessageBtn.addEventListener('click', function () {
              sendMessage(determineSendGptMessageType(contentInput.value));
          });

          contentInput.addEventListener('keypress', function (e) {
              if (e.key === 'Enter' && !e.shiftKey) sendMessageBtn.click()
          });
          contentInput.addEventListener('keypress', function (e) {
              if (e.key === 'Enter' && e.shiftKey && isPlaying) sendGptMessageBtn.click()
          });

          unSubscribeBtn.addEventListener('click', unSubscribe);

          startBtn.addEventListener('click', sendMessage.bind(null, 'TWENTY_GAME_START'));


          document.querySelectorAll('.changeReadyBtn').forEach(btn => {
              let toReady = btn.dataset.toready;
              btn.addEventListener('click', sendMessage.bind(null, toReady == 'true' ? 'TWENTY_GAME_READY' : 'TWENTY_GAME_UNREADY'))
          });

          // function ===============================================================================================

          /**
           * connect 전 상태초기화
           */
          function connectInit() {
              currentUsername = usernameInput.value;
              currentUserId = document.getElementById('userId').value;
              currentRoomId = roomInfo.dataset.roomid;

              sendUrl = '/app/twenty-game/' + currentRoomId;
              subUrl = '/topic/twenty-game/' + currentRoomId;
          }

          // 소켓 연결
          function connect() {

              connectInit();

              // 소켓연결
              let socket = new SockJS('/chat');

              // STOMP 연결
              let headers = setConnectHeaders();
              stompClient = Stomp.over(socket);
              stompClient.debug = null;

              stompClient.connect(headers, function (frame) {
                  setConnected(true);  // 연결후 html 조정
                  // console.log('Connected: ' + frame);

                  // 서버의 endpoint 에 연결 후 메시지 수신마다 콜백실행 (responseMessage 은 서버에서 전송한 메시지)
                  currentSubscription = stompClient.subscribe(subUrl, function (responseMessageDto) {
                      let responseMessage = JSON.parse(responseMessageDto.body)
                      processMessage(responseMessage);
                  });

                  // connect callback
                  initAfterConnect();
              });
          }

          /**
           * connect 후 상태 초기화
           */
          async function initAfterConnect() {
              await initializeMemberList();

              if (thCurrentRoom.isGptActivated) {
                  // 플레이 중 입장 - 관전
                  isPlaying = true;
                  disableAllMenuBtnExceptMemberListBtn();
                  inputStatus.innerText = '관전중';
                  initializeMemberListAlive(isPlaying); // initAfterConnect 관전중 생존표시 초기화
                  // Enter 메시지 수신 후 다시 syncMemberList 가 호출되면서, 내 '생존' 표시는 떨어진다.
              }
          }

// 사용자의 구독해제
          function unSubscribe() {
              if (isCurrentUserRoomOwner) {
                  if (!confirm('방장이 나가면 방이 삭제됩니다. 정말 나가시겠습니까?')) {
                      return;
                  }
              }
              currentSubscription.unsubscribe();
              // index 로 보냄. (뒤로가기 불가)
              location.replace('/');
          }

          function disconnect() {
              if (isCurrentUserRoomOwner && isPlaying) {
                  sendMessage('LEAVE_WHILE_PLAYING'); // 방장이면서 게임중일때 나가면 게임종료
              }
              if (stompClient != null) {
                  stompClient.disconnect(function () {
                  });
              }
              setConnected(false);
          }

// 연결 여부에 따라 입력 및 스타일 조정
          function setConnected(connected) {
              unSubscribeBtn.disabled = !connected;
              conversationInput.style.visibility
                  = connected ? 'visible' : 'hidden';
          }

          /**
           * 메시지의 header 설정하는 함수
           */
          function setConnectHeaders() {
              let headers = {
                  "containsNativeHeader": true,
                  "currentRoomId": currentRoomId,
                  "subUrl": subUrl
              }
              return headers;
          }

          /**
           * 메시지 전송
           * @param chatMessageType 전송할 메시지 타입
           */
          function sendMessage(chatMessageType) {
              let usernameVal = usernameInput.value;
              let contentVal = contentInput.value;

              // 입력값 없으면 중지
              if (!contentVal && (chatMessageType == 'CHAT' || chatMessageType == 'TWENTY_GAME_ASK')) {
                  alert("내용을 입력하세요.")
                  return;
              }

              // 게임중일때 ready, unready 중지
              if (isPlaying && (chatMessageType == 'TWENTY_GAME_READY' || chatMessageType == 'TWENTY_GAME_UNREADY')) {
                  alert('게임중에는 준비상태를 변경할 수 없습니다.');
                  return;
              }

              let isGptChat = chatMessageType == 'TWENTY_GAME_START' ||
              chatMessageType == 'TWENTY_GAME_ASK' ||
              chatMessageType == 'TWENTY_GAME_ANSWER'
                  ? true : false;

              // 스무고개 게임 시작되면 문제 번호 붙이기.
              if (isGptChat) {
                  contentVal = currentQuestionCount + ". " + contentVal;
              }

              let sendMessageDto = {
                  'roomId': thCurrentMember.roomId,
                  'userId': thCurrentMember.userId,
                  'type': chatMessageType,
                  'username': usernameVal,
                  'content': contentVal,
                  'createdAt': '',
                  'isGptChat': isGptChat,       // Gpt 와의 대화인지 여부, 프론트에서 전달

                  'gptUuid': currentGptUuid,            // GPT 의 UUID, UUID(8)
                  'order': myTwentyOrder,                // 진행 시, user 자신의 순서

                  'banUserId': banUserId,        // 강퇴할 userID

                  // 클라이언트의 값은 보내는 의미가 없는 필드들
                  'isTwentyStart': isTwentyStart,    // 시작성공여부
                  'nextUserId': 0,         // 진행 시, gpt 가 내려주는 다음 userId
                  'twentyWinner': '',          //  종료 시, 승자의 username
              }
              // headers = {}
              stompClient.send(sendUrl, {}, JSON.stringify(sendMessageDto));
              contentInput.value = '';
          }

          /**
           * 스무고개 GPT 에게 보내는 메시지의 타입이 TWENTY_GAME_ANSWER 인지 TWENTY_GAME_ASK 인지 결정
           */
          function determineSendGptMessageType(content) {
              // console.log(content)
              return content.includes("정답") ? 'TWENTY_GAME_ANSWER' : 'TWENTY_GAME_ASK';
          }

// 메시지 수신 처리
          async function processMessage(responseMessage) {

              let needShowMessage = true;
              switch (responseMessage.type) {
                  case 'ENTER':
                      await syncMemberList(isPlaying, responseMessage.userId); // ENTER
                      break;

                  case 'LEAVE':
                      await syncMemberList(isPlaying, responseMessage.userId); // LEAVE
                      // 게임중에 LEAVE.isPlaerLeaved = true 메시지가 왔을때 방장이 종료메시지 전송
                      isPlaying && isCurrentUserRoomOwner && responseMessage.isPlayerLeaved ? sendMessage('LEAVE_WHILE_PLAYING') : null;
                      break;

                  case 'CHAT':
                      break;

                  case 'ERROR' :
                      // 일반 에러 메시지는 TWENTY_GAME_ERROR 과 달리 게임중에는 오지 않는다. 후처리 불필요
                      break;

                  case 'TWENTY_GAME_READY':
                      // 상태처리
                      isCurrentUserReady = responseMessage.userId == currentUserId ? true : isCurrentUserReady;
                      await syncMemberList(isPlaying, responseMessage.userId) // READY

                      // 버튼처리
                      changeReadyBtnStyle(isCurrentUserReady);
                      // console.log(isCurrentUserRoomOwner, readyUserCount, allUserCount);
                      isCurrentUserRoomOwner && (readyUserCount == allUserCount) ? enableStartBtn() : disableStartBtn(); // 방장 && 올레디 시작버튼 사용가능

                      needShowMessage = false;
                      break;

                  case 'TWENTY_GAME_UNREADY':
                      // 상태처리
                      isCurrentUserReady = responseMessage.userId == currentUserId ? false : isCurrentUserReady;
                      await syncMemberList(isPlaying, responseMessage.userId); // UNREADY

                      // 버튼처리
                      changeReadyBtnStyle(isCurrentUserReady);
                      isCurrentUserRoomOwner && (readyUserCount == allUserCount) ? enableStartBtn() : disableStartBtn();

                      needShowMessage = false;
                      break;

                  case 'TWENTY_GAME_START':
                      // 상태처리
                      isPlaying = true;
                      initializeMemberListAlive(isPlaying); // 생존자 표시 초기화
                      playerInfoList = responseMessage.memberInfoList;
                      currentGptUuid = responseMessage.gptUuid;
                      initializeOrder();
                      alivePlayerCount = readyUserCount; // 생존자 초기화
                      remainingOrderCount = myTwentyOrder; // 첫 남은순서는 내 order index 만큼.

                      // 버튼 처리
                      disableAllMenuBtnExceptMemberListBtn();
                      sendGptMessageBtn.style.display = 'block';
                      document.querySelectorAll('.ban-member-button').forEach(item => item.style.display = 'none');

                      // 스타일처리
                      infoIsPlaying.innerText = isPlaying ? '게임중' : '대기중';

                      needShowMessage = false;
                      break;

                  case 'TWENTY_GAME_END' :
                      // 상태처리
                      await syncMemberList(isPlaying, responseMessage.userId)// GAME END
                      isPlaying = false;
                      initializeMemberListAlive(isPlaying); // 생존자 표시 초기화
                      isCurrentUserReady = false;
                      twentyWinner = responseMessage.twentyWinner;
                      if (twentyWinner) alert(twentyWinner + " 승리!");
                      isMyFirstTurnElapsed = false;
                      elapsedTurn = 0;
                      currentQuestionCount = 0;
                      isCurrentUserDead = false;

                      // 버튼처리
                      enableAllMenuBtnExceptStartBtn();
                      isCurrentUserRoomOwner && (readyUserCount == allUserCount) ? enableStartBtn() : disableStartBtn();
                      changeReadyBtnStyle(isCurrentUserReady);
                      sendGptMessageBtn.style.display = 'none';
                      document.querySelectorAll('.ban-member-button').forEach(item => item.style.display = 'block');

                      // 스타일처리
                      inputStatus.innerText = '대기중';
                      conversationInput.classList.remove('twenty-asking-conversation-input');
                      infoIsPlaying.innerText = isPlaying ? '게임중' : '대기중';
                      inputStatus.classList.remove('input-status-dead');
                      break;

                  case 'TWENTY_GAME_ERROR':
                      // GPT_PROCESSING 에서 disabled 한 현재차례 sendGptMessageBtn 활성화, nextUserId 는 갱신되지 않음.
                      currentUserId == nextUserId ? sendGptMessageBtn.disabled = false : true;
                      break;

                  case 'GPT_PROCESSING':
                      sendGptMessageBtn.disabled = true;
                      break;

                  case 'TWENTY_GAME_ASK':
                      break;
                  case 'TWENTY_GAME_ANSWER':
                      break;

                  case 'TWENTY_FROM_GPT':
                      // 상태처리
                      await syncMemberList(isPlaying, responseMessage.userId); // TWENTY_FROM_GPT
                      currentQuestionCount++; // 질문 카운트 증가
                      if (responseMessage.twentyDeadUserId) {
                          // 오답자가 존재
                          deadPlayerCount++; // 오답자로 인한 순서 보정을 위해
                          // 현재 유저 오답자확인
                          isCurrentUserDead = responseMessage.twentyDeadUserId == currentUserId ? true : isCurrentUserDead; // 오답자확인
                          document.querySelector('.member-list-item[data-userid="' + responseMessage.twentyDeadUserId + '"] .member-is-twenty-alive').remove() // 오답자 생존마크 제거
                      }

                      // 차례에 따른 후처리
                      nextUserId = responseMessage.nextUserId ? responseMessage.nextUserId : nextUserId; // 다음 유저 id 내려왔을때 만 초기화

                      if (nextUserId == currentUserId) {
                          processMyTurn(); // 내차례
                      } else if(isCurrentUserReady) {
                          processOtherTurn(); // 남의차례 + 내가 레디중(게임참가중) myTwentyOrder != -1 도 가능
                      } else {
                          // 관전중
                      }

                      break;
                  case 'ROOM_DELETED':
                      location.replace('/?isRoomDeleted=true');
                      break;
                  case 'BAN_MEMBER':
                      // 게임중 불가
                      if (responseMessage.banUserId == currentUserId) { location.replace('/?isBanned=true'); } // 강퇴당한사람
                      await syncMemberList(isPlaying, responseMessage.banUserId); // BAN

                      // 버튼처리
                      changeReadyBtnStyle(isCurrentUserReady);
                      isCurrentUserRoomOwner && (readyUserCount == allUserCount) ? enableStartBtn() : disableStartBtn(); // 방장 && 올레디 시작버튼 사용가능
                      break;
                  default:
                      needShowMessage = false;
                      console.log("PROCESS MESSAGE DEFAULT CASE ============================", responseMessage);
                      break;
              } //switch

              if (needShowMessage) showMessage(responseMessage);
          }

          function initializeOrder() {
              playerInfoList.forEach((item) => {
                  if (item.userId == currentUserId) {
                      myTwentyOrder = item.twentyOrder;
                  }
              })
          }

          /**
           * 내차례 후처리
           */
          function processMyTurn() {
              // 상태처리
              elapsedTurn = 0; // 턴 지남 카운트 초기화
              alivePlayerCount -= deadPlayerCount; // 오답자로 인한 생존자 보정
              isMyFirstTurnElapsed = true; // 내 첫 턴 지남 여부

              // 버튼처리
              sendGptMessageBtn.disabled = false;

              // 스타일처리
              conversationInput.classList.add('twenty-asking-conversation-input');// 질문박스 하이라이트
              contentInput.setAttribute('placeholder', '그것은 OOO 입니까?');
              inputStatus.innerText = '스무고개 질문 차례입니다';
          }

          /**
           * 다른사람 차례 후처리
           */
          function processOtherTurn() {
              // 상태처리
              remainingOrderCount = isMyFirstTurnElapsed ? alivePlayerCount - 1 - elapsedTurn : myTwentyOrder - elapsedTurn; // 남은 순서 계산
              elapsedTurn++; // 턴이 종료될때 턴 지남 카운트

              // 버튼처리
              sendGptMessageBtn.disabled = true;

              // 스타일처리
              if (isCurrentUserDead) {
                  // 현재 플레이어 오답자일때
                  inputStatus.innerText = '----당신은 죽었습니다----';
                  inputStatus.classList.add('input-status-dead');
                  conversationInput.classList.remove('twenty-asking-conversation-input');// 질문박스 하이라이트
                  return;
              }
              conversationInput.classList.remove('twenty-asking-conversation-input');

              responseMemberList.forEach((member) => {
                  if (member.userId == nextUserId) {
                      inputStatus.innerText = member.username + ' 님 질문중, ';
                  }
              })

              inputStatus.innerText += ' 내 차례까지 앞으로 ' + remainingOrderCount;
          }

          // 메시지 화면 출력
          function showMessage(chatMessage) {
              // <li listItem>
              //   <div listHeader> <span username> </div>
              //   <div listBody> <span content> <span createdAt> <div>
              // </li>
              let listItem = document.createElement('li');
              let listHeader = document.createElement('div');
              let listBody = document.createElement('div');

              let username = document.createElement('span');
              let content = document.createElement('span');
              let createdAt = document.createElement('span');

              let colorClassName = determineConversationColorClass(chatMessage.username);
              let conversationHighlightClassName = determineConversationTwentyHighlightClass(chatMessage.type);

              if (chatMessage.type == 'GPT_PROCESSING') listItem.classList.add('gpt-processing');
              listItem.classList.add('list-group-item', 'conversation-list-item',);
              listHeader.classList.add('conversation-list-item-header');
              listBody.classList.add('conversation-list-item-body', colorClassName, conversationHighlightClassName);

              username.textContent = chatMessage.username;
              username.classList.add('conversation-list-item-username');
              listHeader.appendChild(username)

              content.textContent = chatMessage.content;
              content.classList.add('conversation-list-item-content');
              listBody.appendChild(content)

              createdAt.textContent = " (" + convertTime(chatMessage.createdAt) + ")";
              createdAt.classList.add('conversation-list-item-created-at');
              listBody.appendChild(createdAt);

              listItem.appendChild(listHeader);
              listItem.appendChild(listBody);
              conversationList.appendChild(listItem);

              if (chatMessage.userId == 3 || chatMessage.type == 'TWENTY_GAME_END') {
                  // GPT_PROCESSING 메시지 삭제 (GAME_END 는 보낸사람이 System 인경우가 있음)
                  document.querySelectorAll('.gpt-processing').forEach(item => item.remove());
              }

              // 스크롤 최하단으로 이동
              conversationBox.scrollTop = conversationWrapper.offsetHeight;

          }

          function determineConversationColorClass(username) {
              let className = "";
              if (username == 'assistant') {
                  className = "bg-success-subtle";
              } else if (username == 'SYSTEM') {
                  className = "systemConversation";
              } else if (username == currentUsername) {
                  className = "bg-primary-subtle";
              } else {
                  // 다른 user
                  className = "otherConversation";
              }
              return className;
          }

          /**
           * 스무고개 ask, answer 메시지의 강조색상 클래스 결정
           */
          function determineConversationTwentyHighlightClass(messageType) {
              let className = "none";
              if (messageType == 'TWENTY_GAME_ASK' || messageType == 'TWENTY_GAME_ANSWER') {
                  className = "twenty-game-ask-conversation";
              }
              if (messageType == 'TWENTY_FROM_GPT') {
                  className = "twenty-game-from-gpt-conversation";
              }
              return className;
          }

          function convertTime(time) {
              // time = "2023-06-07T16:23:47";
              const dateTime = new Date(time); // 원본 시간을 Date 객체로 변환, "2023-06-07T07:23:47.000Z"

              // slice(-2) : 마지막 두글자
              // ex) minute = 3, '0' + minute = '03', ('0' + minute).slice(-2) = '03'
              // ex2) minute = 13, '0' + minute = '013', ('0' + minute).slice(-2) = '13'

              const year = dateTime.getFullYear().toString().slice(2); // 연도에서 뒤의 두자리만 가져옴
              const month = ('0' + (dateTime.getMonth() + 1)).slice(-2); // 월을 가져오고, 1을 더한 뒤, 앞에 0을 붙임
              const day = ('0' + dateTime.getDate()).slice(-2); // 일을 가져오고, 앞에 0을 붙임
              const hour = ('0' + dateTime.getHours()).slice(-2); // 시간을 가져오고, 앞에 0을 붙임
              const minute = ('0' + dateTime.getMinutes()).slice(-2); // 분을 가져오고, 앞에 0을 붙임
              const second = ('0' + dateTime.getSeconds()).slice(-2); // 초를 가져오고, 앞에 0을 붙임

              const formattedDateTime = `${year}-${month}-${day} ${hour}:${minute}:${second}`; // "yy-MM-dd HH:mm:ss" 형태로 포맷팅합니다.

              // console.log(formattedDateTime); // 예시 출력: "23-06-07 16:23:47"
              return formattedDateTime;
          }

          /**
           * 처음들어갈때 멤버리스트 초기화 및 생성
           */
          async function initializeMemberList() {

              const response = await fetchMemberList();
              // console.log('initializeMemberList()', response);
              responseMemberList = response.memberList;

              allUserCount = responseMemberList.length;

              // 서버에서 받은 responseMemberList 순회
              responseMemberList.forEach(member => {
                  let newMemberListItem = createMemberListItem(member);
                  memberList.appendChild(newMemberListItem);
              })
          }

          /**
           * 게임 시작하면 생존마커 전부 붙이고, 끝나면 전부 뗌.
           */
          function initializeMemberListAlive(isPlaying) {
              if (isPlaying) {
                  // 게임중
                  memberList.querySelectorAll('.member-list-item-content').forEach(item => {
                      let memberIsTwentyAlive = document.createElement('span');
                      memberIsTwentyAlive.classList.add('member-is-twenty-alive');
                      memberIsTwentyAlive.textContent = '생존';
                      item.appendChild(memberIsTwentyAlive);
                  })
              } else {
                  //게임끝
                  memberList.querySelectorAll('.member-is-twenty-alive').forEach(item => {
                      item.remove();
                  });
              }
          }

          async function syncMemberList(isPlaying, responseMessageUserId) {
              if (responseMessageUserId == 0 || responseMessageUserId == null) return;

              const response = await fetchMemberList(); // 멤버리스트를 반환하는것을 대기.

              // console.log(response);
              responseMemberList = response.memberList;

              let modifiedMemberListItem = null; // htmlCollection
              let modifiedMemberResponse = null; // Object
              readyUserCount = isPlaying ? readyUserCount : 0
              allUserCount = responseMemberList.length;

              // 파라미터로 받은 메시지의 userId 와 동일한 userId 를 가진 member-list-item 을 찾는다.
              for (let i = 0; i < memberList.children.length; i++) {
                  if (memberList.children[i].dataset.userid == responseMessageUserId) {
                      modifiedMemberListItem = memberList.children[i];
                  }
              }

              // console.log(modifiedMemberListItem);

              // 서버에서 받은 responseMemberList 순회
              responseMemberList.forEach(responseMember => {
                  // 수정할 멤버의 정보를 찾는다.
                  if (responseMember.userId == responseMessageUserId) {
                      modifiedMemberResponse = responseMember;
                  }

                  if (isPlaying) return; // 플레이중인경우 후처리 무시

                  // ready 된 유저 수 계산
                  readyUserCount = responseMember.isTwentyGameReady ? ++readyUserCount : readyUserCount;
              });

              // console.log("readyUserCount : " + readyUserCount);

              // memberList 그리기
              // CHAT_FROM_GPT 에서는, userId 가 GPT 의 id 이기 때문에, 갱신되지 않는다.
              if (modifiedMemberResponse == null) {
                  // 수정할 멤버의 정보가 없음
                  if (modifiedMemberListItem != null) {
                      // list-item 은 존재함 -> 삭제
                      modifiedMemberListItem.remove();
                  }
              } else {
                  // 수정할 멤버의 정보가 있음 -> newListItem 생성
                  let newMemberListItem = createMemberListItem(modifiedMemberResponse);
                      if (modifiedMemberListItem == null) {
                          // 수정할 멤버의 정보 있음, list-item 없음, -> 새 list-item 추가
                          memberList.appendChild(newMemberListItem);
                      } else {
                          // 수정할 멤버의 정보 있음, list-item 있음 -> 새 list-item 으로 교체
                          modifiedMemberListItem.replaceWith(newMemberListItem);
                  }
              }
          } // syncMemberList()

          function fetchMemberList() {
              let responsePromise = fetch('/twenty-game/room/' + currentRoomId + '/members');
              return responsePromise.then(response => response.json()) // json 형태의 데이터를 자바스크립트 객체로 변환
          }

          /**
           * 수정할 멤버의 정보를 받아서, 새로운 list-item 을 생성한다.
           * @param modifiedMemberResponse : 서버로 부터 받은 수정할 멤버의 정보 Object
           */
          function createMemberListItem(modifiedMemberResponse) {
              let newMemberListItem = document.createElement('li');
              newMemberListItem.classList.add('list-group-item', 'member-list-item');
              newMemberListItem.dataset.userid = modifiedMemberResponse.userId;

              let newMemberListItemHeader = document.createElement("div");
              newMemberListItemHeader.classList.add('member-list-item-header');
              let newMemberListItemContent = document.createElement("div");
              newMemberListItemContent.classList.add('member-list-item-content');

              let memberUsername = document.createElement('span');
              memberUsername.classList.add('member-username');
              memberUsername.textContent = modifiedMemberResponse.username;
              newMemberListItemHeader.appendChild(memberUsername);

              let isRoomOwner = modifiedMemberResponse.isRoomOwner; // boolean
              if (isRoomOwner) {
                  // 수정 대상이 방장
                  let memberIsRoomOwner = document.createElement('span');
                  memberIsRoomOwner.classList.add('member-is-room-owner');
                  memberIsRoomOwner.textContent = '방장';
                  newMemberListItemHeader.appendChild(memberIsRoomOwner);
              } else {
                  // 수정대상이 방장이 아님
                  if (isCurrentUserRoomOwner) {
                      // 내가 방장임 - 수정 대상에 ban 버튼 추가
                      let banMemberButton = document.createElement('button');
                      banMemberButton.classList.add('btn', 'btn-outline-danger', 'ban-member-button');
                      banMemberButton.textContent = '강퇴';
                      banMemberButton.onclick = banMember;
                      newMemberListItemHeader.appendChild(banMemberButton);
                  }
              }

              let isMemberConnected = modifiedMemberResponse.isRoomConnected; // boolean
              let memberIsRoomConnected = document.createElement('span');
              memberIsRoomConnected.classList.add('member-is-room-connected');
              let connectedColorClass = isMemberConnected ? 'member-connected' : 'member-disconnected';
              memberIsRoomConnected.classList.add(connectedColorClass);
              memberIsRoomConnected.textContent = isMemberConnected ? '접속중' : "미접속";
              newMemberListItemContent.appendChild(memberIsRoomConnected);

              // 게임중이 아닐때 레디상태 표시
              let isTwentyReady = modifiedMemberResponse.isTwentyGameReady; // boolean
              let memberIsTwentyReady = document.createElement('span');
              memberIsTwentyReady.classList.add('member-is-twenty-ready');
              memberIsTwentyReady.textContent = isTwentyReady ? '준비됨' : '';
              newMemberListItemContent.appendChild(memberIsTwentyReady);

              newMemberListItem.appendChild(newMemberListItemHeader);
              newMemberListItem.appendChild(newMemberListItemContent);

              return newMemberListItem;
          }

          function changeReadyBtnStyle(isCurrentUserReady) {
              if (isCurrentUserReady == true) {
                  // 준비하기(readyBtn) 클릭, 준비됨(unReadyBtn) 으로 변경
                  readyBtn.style.display = 'none';
                  unReadyBtn.style.display = 'block';
              } else {
                  // 준비됨(unReadyBtn) 클릭, 준비하기(readyBTn) 로 변경
                  readyBtn.style.display = 'block';
                  unReadyBtn.style.display = 'none';
              }
          }

          /**
           * 멤버정보 버튼 제외 모든 #menuBar 내부 버튼 비활성화
           */
          function disableAllMenuBtnExceptMemberListBtn() {
              document.querySelectorAll('#menuBar button').forEach(function (item) {
                  item.disabled = true;
              });
              memberListBtn.disabled = false;
          }

          /**
           * 시작버튼 제외 모든 #menuBar 내부 버튼 활성화
           */
          function enableAllMenuBtnExceptStartBtn() {
              document.querySelectorAll('#menuBar button').forEach(function (item) {
                  item.disabled = false;
              });
              startBtn.disabled = true;
          }

          function enableStartBtn() {
              startBtn.disabled = false;
              startBtn.classList.replace('btn-outline-secondary', 'btn-outline-primary');
          }

          function disableStartBtn() {
              startBtn.disabled = true;
              startBtn.classList.replace('btn-outline-primary', 'btn-outline-secondary');
          }

          function banMember() {
              banUserId = this.parentElement.parentElement.dataset.userid; // list-item-header -> list-item .userId
              let username = this.parentElement.parentElement.querySelector('.member-username').textContent;
              let banConfirm = confirm(username + '님을 강퇴하시겠습니까?');
              if (banConfirm && banUserId && !isPlaying) {
                  // 컨펌확인, banUserId 존재, 게임중이 아닐때만 강퇴
                  sendMessage('BAN_MEMBER');
                  banUserId = 0;
              }
          }


      }); // DOMContentLoaded

  </script>
</head>
<body>
<div id="container" class="container">

  <div id="headerContainer">
    <div id="roomHeader">
      <h2 th:text="${chatRoom.getName()}">RoomName</h2>
    </div>

    <!-- tutorial modal -->
    <div class="modal fade" id="twentyTutorialModal" tabindex="-1" aria-labelledby="twentyTutorialModal"
         aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h1 class="modal-title fs-5" id="twentyTutorialModalHeader">게임 방법</h1>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>

          <div class="modal-body">
            <ul id="twentyTutorialList" class="list-group">
              <li class="list-group-item">
                1. 방장은 게임 시작 버튼을 눌러 게임을 시작합니다.
              </li>
              <li class="list-group-item">
                2. 자신의 차례에만 GPT 에게 질문 할 수 있습니다.<br>
                메시지 입력후 Enter 누르면 일반채팅, <br>
                Shift + Enter 누르면 질문으로 전송됩니다.
              </li>
              <li class="list-group-item">
                3. 메시지에 "정답" 을 포함하여 질문하면, 정답 여부를 확인합니다.<br>
                정답 여부는 한번만 확인하며, 틀리면 해당 유저는 이후 질문할 수 없습니다.
              </li>
              <li class="list-group-item">
                4. 게임 도중 유저가 퇴장하면 즉시 게임이 종료됩니다.
              </li>
            </ul>
          </div>

          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
          </div>
          </form>

        </div>
      </div>
    </div>

    <hr>

    <div id="roomInfo" th:data-roomid="${chatRoom.id}">
      <!--    <span id="roomId" th:text="|id ${chatRoom.id}|" th:data-roomid="${chatRoom.id}">roomId</span>-->
      <!--    <span id="roomName" th:text="|name ${chatRoom.getName}|">roomName</span>-->
      <span id="roomType" th:text="|${chatRoom.getType().roomTypeName}|">roomType</span>
      <span id="twentySubject" th:text="'주제: ' + ${chatRoom.subject.getSubjectName()}"></span>
      <span id="twentyCustomSubject" th:if="${chatRoom.subject == T(chat.twenty.enums.TwentyGameSubject).CUSTOM}"
            th:text="'->' + ${chatRoom.customSubject}"></span>
      <span id="infoIsPlaying">대기중</span>
    </div>

    <hr>

    <!-- Modal -->
    <div class="modal fade" id="memberListModal" tabindex="-1" aria-labelledby="memberListModal" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h1 class="modal-title fs-5" id="memberListModalLabel">멤버 정보</h1>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>

          <div class="modal-body">
            <ul id="memberList" class="list-group list-group-flush">
            </ul>
          </div>

          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
          </div>
          </form>

        </div>
      </div>
    </div>

    <div id="menuContainer">
      <div id="menuBar" class="input-group">
        <button id="memberListBtn" type="button" class="btn btn-outline-success" data-bs-toggle="modal"
                data-bs-target="#memberListModal">
          멤버 정보
        </button>
        <button id="readyBtn" class="btn btn-outline-primary changeReadyBtn" data-toready="true">준비하기</button>
        <button id="unReadyBtn" class="btn btn-outline-info changeReadyBtn" data-toready="false">준비됨</button>
        <button id="startBtn" class="btn btn-outline-secondary" disabled>게임시작</button>
        <button id="unSubscribeBtn" class="btn btn-outline-danger" disabled='true'>퇴장</button>
      </div>
      <button id="twentyTutorialModalBtn" class="btn btn-outline-warning"
              data-bs-toggle="modal"
              data-bs-target="#twentyTutorialModal">?
      </button>
    </div>

    <hr>
  </div>
  <div id="contentContainer">
    <div id="conversationBox" class="card">
      <div id="conversationWrapper" class="card-body">
        <ul id="conversationList" class="list-group">
          <!-- Messages will be dynamically added here -->
        </ul>
      </div>
    </div>

    <div id="inputStatusBox">
      <p id="inputStatus">대기중</p>
    </div>
    <form id="conversationInput" class="input-group" sec:authorize="isAuthenticated()">
      <input type="hidden" name="_csrf" th:value="${_csrf.token}"/>
      <div class="input-group">
        <input type="text" id="blockSubmit" style="display: none"/>
        <input type="text" id="contentInput" class="form-control" placeholder="채팅 메시지 입력" value="" required/>
        <input type="hidden" id="usernameInput" th:value="${#authentication.name}"/>
        <input type="hidden" id="order" value="0"/>
        <input type="hidden" id="userId" th:value="${#authentication.principal.id}">
        <div class="input-group-append">
          <button type="button" id="sendMessageBtn" class="btn btn-outline-primary">보내기</button>
        </div>
        <div class="input-group-append">
          <button type="button" id="sendGptMessageBtn" class="btn btn-outline-success">질문하기</button>
        </div>
      </div>
    </form>
  </div>
</div> <!-- container -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ENjdO4Dr2bkBIFxQpeoTz1HIcje39Wm4jDKdf19U8gI4ddQ3GYNS7NTKfAdVQSZe"
        crossorigin="anonymous"></script>
</body>
</html>
