<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Chat WebSocket</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">
  <style>

      .container hr {
          margin: 0.5rem;
      }

      #roomHeader, #roomInfo {
          text-indent: 15px;
      }

      #roomHeader {
          margin-top: 10px;
      }

      #roomInfo span {
          margin-right: 10px;
      }

      #menuContainer {
          margin: 20px auto;
      }

      #sendGptMessageBtn {
          display: none;
      }

      #unReadyBtn {
          display: none;
      }

      #conversationBox {
          margin-bottom: 20px;
          height: 70vh; /* 70% of the viewport height */
          overflow: hidden;
          overflow-y: scroll;
      }

      .member-connected {
          color: green;
      }

      .member-disconnected {
          color: grey;
      }

      .member-list-item span {
          margin-right: 15px;
          font-size: 1.2em;
      }

      #conversationWrapper {
          padding: 0;
      }

      .conversation-list-item {
          /*background-color: white;*/
          /*border-style: solid;*/
          /*border-width: medium;*/
          border-bottom: none;
      }

      .conversation-list-item-body {
          padding: 10px;
          border-radius: 10px;
      }

      .conversation-list-item-username {

      }

      .conversation-list-item-content {

      }

      .twenty-game-ask-conversation .conversation-list-item-content {
          font-weight: bold;
      }

      .twenty-game-from-gpt-conversation .conversation-list-item-content {
          font-weight: bold;
      }

      .conversation-list-item-created-at {
          font-size: 0.8em;
      }

      .twenty-game-ask-conversation, .twenty-game-from-gpt-conversation {
          border-left: red solid 3px;
      }

      /*.twenty-game-from-gpt-conversation {*/
      /*    border-bottom: green solid 4px;*/
      /*}*/

      .myConversation {
          /*background-color: lightblue;*/
      }

      .otherConversation {
          background-color: whitesmoke;
      }

      .gptConversation {
          /*background-color: lightgreen;*/
      }

      .systemConversation {
          background-color: ghostwhite;
      }

      .twenty-asking-conversation-input {
          border: green solid 3px;
      }


  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.4.0/sockjs.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
  <script type="text/javascript" th:inline="javascript">

      /*<![CDATA[*/
      let thCurrentMember = [[${currentMember}]];
      /*]]>*/

      // STOMP 변수
      let stompClient = null;
      let currentSubscription = null;

      // 서버에서 내려주는 TwentyMessageDto 구조. (사용X)
      const TwentyMessageDto = {
          roomId: 0,
          userId: 0,
          type: '',
          username: '',
          content: '',
          createdAt: '',
          isGptChat: false,       // Gpt 와의 대화인지 여부, 프론트에서 전달

          gptUuid: null,            // GPT 의 UUID, UUID(8)
          isTwentyStart: false,    // 시작시, 시작성공여부
          orderArray: null,        // 시작시, 순서 정하기 위해 섞은 배열
          order: 0,                // 진행 시, user 자신의 순서
          twentyNext: 0,         // 진행 시, gpt 가 내려주는 다음 순서
          twentyWinner: '',          //  종료 시, 승자의 username
          twentyDeadUserId: 0,    // 오답시 오답자의 id
      }


      document.addEventListener('DOMContentLoaded', function () {

          // DOM 요소 탐색
          let usernameInput = document.getElementById('usernameInput');
          let contentInput = document.getElementById('contentInput');
          let roomInfo = document.getElementById('roomInfo');

          let infoGptActivated = document.getElementById('infoGptActivated');
          let infoGptOwner = document.getElementById('infoGptOwner');

          let conversationInput = document.getElementById('conversationInput');
          let conversationList = document.getElementById('conversationList');
          let conversationBox = document.getElementById('conversationBox');
          let conversationWrapper = document.getElementById('conversationWrapper');

          let memberList = document.getElementById('memberList');

          // 이벤트 리스터용 DOM 요소 탐색
          let memberListBtn = document.getElementById('memberListBtn');
          let sendMessageBtn = document.getElementById('sendMessageBtn');
          let sendGptMessageBtn = document.getElementById('sendGptMessageBtn');
          let unSubscribeBtn = document.getElementById('unSubscribeBtn');
          let startBtn = document.getElementById('startBtn');
          let readyBtn = document.getElementById('readyBtn');
          let unReadyBtn = document.getElementById('unReadyBtn');
          let inputStatus = document.getElementById('inputStatus');

          // connect connectInit()
          let sendUrl = '';
          let subUrl = '';
          let currentRoomId = '';
          let currentUserId = '';
          let currentUsername = '';

          // 필요시 초기화될 변수
          let readyUserCount = 0;
          let allUserCount = 0;
          let isCurrentUserReady = false;
          let isTwentyStart = false; // 서버에서 스무고개 시작 여부 확인후 전송됨
          let orderArray = null; // 서버에서 스무고개 시작후 내려준 순서결정용 배열
          let myMemberOrder = -1; // 멤버 순서 (syncMemberList 에서 갱신)
          let myTwentyOrder = -1; // 스무고개 순서 (TWENTY_GAME_START 메시지 오면 갱신)
          let currentGptUuid; // 스무고개 START 하면 서버에서 uuid 받아서 초기화
          let twentyWinner;
          let currentQuestionCount = 0; // 메시지에 표시하기위해 작성됨
          let remainingOrderCount; // 내 차례까지 남은 횟수. alivePlayerCount 를 대입한뒤 GPT_ANSWER 마다 1씩감소
          // alivePlayerCount 가 -- 될때마다 얘도 --
          let isPlaying = false; // 게임중인지 여부. TWENTY_GAME_START, TWENTY_GAME_END 에서 갱신, sync 에서 사용
          let isCurrentUserDead = false; // 내가 오답자인지 여부. TWENTY_FROM_GPT 에서 갱신
          let alivePlayerCount = 0; // START 에서 readyUserCount 대입 후, 오답자가 나올때 마다 --

          // 초기 Connect 호출
          connect();

          // eventListener =====================================================================================

          window.addEventListener("beforeunload", function (event) {
              console.log('event.beforeunload');
              disconnect();
          });

          sendMessageBtn.addEventListener('click', sendMessage.bind(null, 'CHAT'));
          sendGptMessageBtn.addEventListener('click', function () {
              sendMessage(determineSendGptMessageType(contentInput.value));
          });

          contentInput.addEventListener('keypress', function (e) {
              if (e.key === 'Enter' && !e.shiftKey) sendMessageBtn.click()
          });
          contentInput.addEventListener('keypress', function (e) {
              if (e.key === 'Enter' && e.shiftKey && isPlaying) sendGptMessageBtn.click()
          });

          unSubscribeBtn.addEventListener('click', unSubscribe);

          startBtn.addEventListener('click', sendMessage.bind(null, 'TWENTY_GAME_START'));


          document.querySelectorAll('.changeReadyBtn').forEach(btn => {
              let toReady = btn.dataset.toready;
              btn.addEventListener('click', sendMessage.bind(null, toReady == 'true' ? 'TWENTY_GAME_READY' : 'TWENTY_GAME_UNREADY'))
          });

          // function ===============================================================================================

          // connect 전 상태 초기화
          function connectInit() {
              currentUsername = usernameInput.value;
              currentUserId = document.getElementById('userId').value;
              currentRoomId = roomInfo.dataset.roomid;

              sendUrl = '/app/twenty-game/' + currentRoomId;
              subUrl = '/topic/twenty-game/' + currentRoomId;

              if (thCurrentMember != null) {
                  if (thCurrentMember.roomOwner == true) startBtn.removeAttribute('disabled');
              }
          }

          // 소켓 연결
          function connect() {

              connectInit();

              // 소켓연결
              let socket = new SockJS('/chat');

              // STOMP 연결
              let headers = setConnectHeaders();
              stompClient = Stomp.over(socket);

              stompClient.connect(headers, function (frame) {
                  setConnected(true);  // 연결후 html 조정
                  console.log('Connected: ' + frame);

                  // 서버의 endpoint 에 연결 후 메시지 수신마다 콜백실행 (responseMessage 은 서버에서 전송한 메시지)
                  currentSubscription = stompClient.subscribe(subUrl, function (responseMessageDto) {
                      let responseMessage = JSON.parse(responseMessageDto.body)
                      processMessage(responseMessage);
                  });
                  // 멤버리스트 초기화
                  initializeMemberList();
              });
          }

// 사용자의 구독해제
          function unSubscribe() {
              currentSubscription.unsubscribe();
              // index 로 보냄. (뒤로가기 불가)
              location.replace('/');
          }

          function disconnect() {
              if (stompClient != null) {
                  stompClient.disconnect(function () {
                  });
              }
              setConnected(false);
              console.log("Disconnected");
          }

// 연결 여부에 따라 입력 및 스타일 조정
          function setConnected(connected) {
              unSubscribeBtn.disabled = !connected;
              conversationInput.style.visibility
                  = connected ? 'visible' : 'hidden';
          }

          /**
           * 메시지의 header 설정하는 함수
           */
          function setConnectHeaders() {
              let headers = {
                  "containsNativeHeader": true,
                  "currentRoomId": currentRoomId,
                  "subUrl": subUrl
              }
              return headers;
          }

// 메시지 전송
          function sendMessage(chatMessageType) {
              let usernameVal = usernameInput.value;
              let contentVal = contentInput.value;
              let isGptChat = chatMessageType == 'TWENTY_GAME_START' ||
              chatMessageType == 'TWENTY_GAME_ASK' ||
              chatMessageType == 'TWENTY_GAME_ANSWER'
                  ? true : false;

              // 스무고개 게임 시작되면 문제 번호 붙이기.
              if (isGptChat) {
                  contentVal = currentQuestionCount + ". " + contentVal;
              }

              let sendMessageDto = {
                  'roomId': thCurrentMember.roomId,
                  'userId': thCurrentMember.userId,
                  'type': chatMessageType,
                  'username': usernameVal,
                  'content': contentVal,
                  'createdAt': '',
                  'isGptChat': isGptChat,       // Gpt 와의 대화인지 여부, 프론트에서 전달

                  'gptUuid': currentGptUuid,            // GPT 의 UUID, UUID(8)
                  'order': myTwentyOrder,                // 진행 시, user 자신의 순서

                  // 클라이언트의 값은 보내는 의미가 없는 필드들
                  'isTwentyStart': isTwentyStart,    // 시작성공여부
                  'orderArray': orderArray,        // 시작시, 순서 정하기 위해 섞은 배열
                  'twentyNext': 0,         // 진행 시, gpt 가 내려주는 다음 순서
                  'twentyWinner': '',          //  종료 시, 승자의 username
              }
              // headers = {}
              stompClient.send(sendUrl, {}, JSON.stringify(sendMessageDto));
          }

          /**
           * 스무고개 GPT 에게 보내는 메시지의 타입이 TWENTY_GAME_ANSWER 인지 TWENTY_GAME_ASK 인지 결정
           */
          function determineSendGptMessageType(content) {
              console.log(content)
              console.log(content.includes("정답"));
              return content.includes("정답") ? 'TWENTY_GAME_ANSWER' : 'TWENTY_GAME_ASK';
          }

// 메시지 수신 처리
          function processMessage(responseMessage) {

              let needShowMessage = true;
              switch (responseMessage.type) {
                  case 'ENTER':
                      syncMemberList(isPlaying, responseMessage.userId);
                      break;

                  case 'LEAVE':
                      syncMemberList(isPlaying, responseMessage.userId);
                      break;

                  case 'TWENTY_GAME_READY':
                      // 상태처리
                      isCurrentUserReady = responseMessage.userId == currentUserId ? true : isCurrentUserReady;

                      // 버튼처리
                      changeReadyBtnStyle(isCurrentUserReady);

                      syncMemberList(isPlaying, responseMessage.userId) // 멤버리스트 갱신
                      needShowMessage = false;
                      break;

                  case 'TWENTY_GAME_UNREADY':
                      // 상태처리
                      isCurrentUserReady = responseMessage.userId == currentUserId ? false : isCurrentUserReady;

                      // 버튼처리
                      changeReadyBtnStyle(isCurrentUserReady);

                      syncMemberList(isPlaying, responseMessage.userId); // 멤버리스트 갱신
                      needShowMessage = false;
                      break;

                  case 'TWENTY_GAME_START':

                      // GPT_PROCESSING 메시지 삭제
                      document.querySelectorAll('.gpt-processing').forEach(item => item.remove());
                      // 상태처리
                      currentGptUuid = responseMessage.gptUuid;
                      myTwentyOrder = responseMessage.orderArray[myMemberOrder];
                      alivePlayerCount = readyUserCount; // 생존자 초기화
                      isPlaying = true;

                      // 버튼 처리
                      disableAllMenuBtnExceptMemberList();
                      sendGptMessageBtn.style.display = 'block';

                      needShowMessage = false;
                      break;

                  case 'TWENTY_GAME_END' :
                      // GPT_PROCESSING 메시지 삭제
                      document.querySelectorAll('.gpt-processing').forEach(item => item.remove());

                      // 상태처리
                      isPlaying = false;
                      twentyWinner = responseMessage.twentyWinner;
                      alert(twentyWinner + " 승리");

                      // 버튼처리
                      enableAllMenuBtn();
                      changeReadyBtnStyle(isCurrentUserReady);
                      sendGptMessageBtn.style.display = 'none';

                      // 스타일처리
                      inputStatus.innerText = '대기중';
                      conversationInput.classList.remove('twenty-asking-conversation-input');

                      syncMemberList(isPlaying, responseMessage.userId)// 멤버리스트 갱신
                      break;

                  case 'TWENTY_GAME_ERROR':
                      break;

                  case 'GPT_PROCESSING':
                      sendGptMessageBtn.disabled = true;
                      break;

                  case 'TWENTY_GAME_SKIP':
                      // 상태처리
                      // remainingOrderCount = responseMessage.twentyNext == myTwentyOrder ? alivePlayerCount : remainingOrderCount--;

                      // 차례에 따른 후처리
                      responseMessage.twentyNext == myTwentyOrder ? processMyTurn() : processOtherTurn();

                      needShowMessage = false;
                      break;

                  case 'TWENTY_FROM_GPT':
                      currentQuestionCount++; // 질문 카운트 증가
                      if (responseMessage.twentyDeadUserId) {
                          // 오답자가 존재
                          alivePlayerCount--; // 오답자로 인한 순서 보정
                          remainingOrderCount--; // 오답자로 인한 순서 보정
                          // 현재 유저 오답자확인
                          isCurrentUserDead = responseMessage.twentyDeadUserId == currentUserId ? true : isCurrentUserDead; // 오답자확인
                      }

                      // GPT_PROCESSING 메시지 삭제
                      document.querySelectorAll('.gpt-processing').forEach(item => item.remove());

                      // 차례에 따른 후처리
                      responseMessage.twentyNext == myTwentyOrder ? processMyTurn() : processOtherTurn();

              } //switch

              if (needShowMessage) showMessage(responseMessage);
          }

          /**
           * 내차례 후처리
           */
          function processMyTurn() {
              // 상태처리
              remainingOrderCount = alivePlayerCount; // 내차례가 돌아오면, 남은차례 초기화

              // 내가 오답자면, 상태만 처리한 후, 바로 SKIP 메시지 전송
              if (isCurrentUserDead) {
                  sendMessage('TWENTY_GAME_SKIP');
                  return;
              }

              // 버튼처리
              sendGptMessageBtn.disabled = false;

              // 스타일처리
              conversationInput.classList.add('twenty-asking-conversation-input');// 질문박스 하이라이트
              contentInput.setAttribute('placeholder', '그것은 OOO 입니까?');
              inputStatus.innerText = '스무고개 질문 차례입니다';
          }

          /**
           * 다른사람 차례 후처리
           */
          function processOtherTurn() {
              // 상태처리
              remainingOrderCount--;

              // 버튼처리
              sendGptMessageBtn.disabled = true;

              // 스타일처리
              if (isCurrentUserDead) {
                  // 현재 플레이어 오답자일때
                  inputStatus.innerText = '당신은 죽었습니다.';
                  return;
              }
              conversationInput.classList.remove('twenty-asking-conversation-input');
              inputStatus.innerText = '내 차례까지 앞으로 ' + remainingOrderCount;
          }

          // 메시지 화면 출력
          function showMessage(chatMessage) {
              // <li listItem>
              //   <div listHeader> <span username> </div>
              //   <div listBody> <span content> <span createdAt> <div>
              // </li>
              let listItem = document.createElement('li');
              let listHeader = document.createElement('div');
              let listBody = document.createElement('div');

              let username = document.createElement('span');
              let content = document.createElement('span');
              let createdAt = document.createElement('span');

              let colorClassName = determineConversationColorClass(chatMessage.username);
              let conversationHighlightClassName = determineConversationTwentyHighlightClass(chatMessage.type);

              if (chatMessage.type == 'GPT_PROCESSING') listItem.classList.add('gpt-processing');
              listItem.classList.add('list-group-item', 'conversation-list-item',);
              listHeader.classList.add('conversation-list-item-header');
              listBody.classList.add('conversation-list-item-body', colorClassName, conversationHighlightClassName);

              username.textContent = chatMessage.username + ": ";
              username.classList.add('conversation-list-item-username');
              listHeader.appendChild(username)

              content.textContent = chatMessage.content;
              content.classList.add('conversation-list-item-content');
              listBody.appendChild(content)

              createdAt.textContent = " (" + convertTime(chatMessage.createdAt) + ")";
              createdAt.classList.add('conversation-list-item-created-at');
              listBody.appendChild(createdAt);

              listItem.appendChild(listHeader);
              listItem.appendChild(listBody);
              conversationList.appendChild(listItem);

              // 스크롤 최하단으로 이동
              conversationBox.scrollTop = conversationWrapper.offsetHeight;

              contentInput.value = '';
          }

          function determineConversationColorClass(username) {
              let className = "";
              if (username == 'assistant') {
                  className = "bg-success-subtle";
              } else if (username == 'SYSTEM') {
                  className = "systemConversation";
              } else if (username == currentUsername) {
                  className = "bg-primary-subtle";
              } else {
                  // 다른 user
                  className = "otherConversation";
              }
              return className;
          }

          /**
           * 스무고개 ask, answer 메시지의 강조색상 클래스 결정
           */
          function determineConversationTwentyHighlightClass(messageType) {
              let className = "none";
              if (messageType == 'TWENTY_GAME_ASK') {
                  className = "twenty-game-ask-conversation"
              }
              if (messageType == 'TWENTY_FROM_GPT') {
                  className = "twenty-game-from-gpt-conversation"
              }
              return className;
          }

          function convertTime(time) {
              // time = "2023-06-07T16:23:47";
              const dateTime = new Date(time); // 원본 시간을 Date 객체로 변환, "2023-06-07T07:23:47.000Z"

              // slice(-2) : 마지막 두글자
              // ex) minute = 3, '0' + minute = '03', ('0' + minute).slice(-2) = '03'
              // ex2) minute = 13, '0' + minute = '013', ('0' + minute).slice(-2) = '13'

              const year = dateTime.getFullYear().toString().slice(2); // 연도에서 뒤의 두자리만 가져옴
              const month = ('0' + (dateTime.getMonth() + 1)).slice(-2); // 월을 가져오고, 1을 더한 뒤, 앞에 0을 붙임
              const day = ('0' + dateTime.getDate()).slice(-2); // 일을 가져오고, 앞에 0을 붙임
              const hour = ('0' + dateTime.getHours()).slice(-2); // 시간을 가져오고, 앞에 0을 붙임
              const minute = ('0' + dateTime.getMinutes()).slice(-2); // 분을 가져오고, 앞에 0을 붙임
              const second = ('0' + dateTime.getSeconds()).slice(-2); // 초를 가져오고, 앞에 0을 붙임

              const formattedDateTime = `${year}-${month}-${day} ${hour}:${minute}:${second}`; // "yy-MM-dd HH:mm:ss" 형태로 포맷팅합니다.

              console.log(formattedDateTime); // 예시 출력: "23-06-07 16:23:47"
              return formattedDateTime;
          }

          /**
           * 처음들어갈때 멤버리스트 초기화 및 생성 (한번만 실행)
           */
          function initializeMemberList() {
              fetch('/twenty-game/room/' + currentRoomId + '/members')
                  .then(response => response.json()) // json 형태의 데이터를 자바스크립트 객체로 변환
                  .then(data => {
                      console.log(data);
                      let responseMemberList = data.memberList;

                      // 서버에서 받은 responseMemberList 순회
                      for (let i = 0; i < responseMemberList.length; i++) {
                          let newMemberListItem = createMemberListItem(responseMemberList[i]);
                          memberList.appendChild(newMemberListItem);
                      }
                  });
          }

          function syncMemberList(isPlaying, responseMessageUserId) {
              if (responseMessageUserId == 0 || responseMessageUserId == null) return;

              fetch('/twenty-game/room/' + currentRoomId + '/members')
                  .then(response => response.json()) // json 형태의 데이터를 자바스크립트 객체로 변환
                  .then(data => {
                      console.log(data);
                      let responseMemberList = data.memberList;

                      let modifiedMemberListItem = null; // htmlCollection
                      let modifiedMemberResponse = null; // Object
                      readyUserCount = isPlaying ? readyUserCount : 0
                      allUserCount = memberList.length;

                      // 파라미터로 받은 메시지의 userId 와 동일한 userId 를 가진 member-list-item 을 찾는다.
                      for (let i = 0; i < memberList.children.length; i++) {
                          if (memberList.children[i].dataset.userid == responseMessageUserId) {
                              modifiedMemberListItem = memberList.children[i];
                          }
                      }

                      console.log(modifiedMemberListItem);

                      // 서버에서 받은 responseMemberList 순회
                      for (let i = 0; i < responseMemberList.length; i++) {
                          // 수정할 멤버의 정보를 찾는다.
                          if (responseMemberList[i].userId == responseMessageUserId) {
                              modifiedMemberResponse = responseMemberList[i];
                          }

                          if (isPlaying) continue; // 플레이중인경우 후처리 무시

                          // ready 된 유저 수 계산
                          readyUserCount = responseMemberList[i].isTwentyGameReady ? ++readyUserCount : readyUserCount;

                          // 내 순서 결정용 memberOrder 설정
                          myMemberOrder = responseMemberList[i].userId == currentUserId ? i : myMemberOrder;

                      }

                      remainingOrderCount = readyUserCount; // 실 플레이 유저 수 대입 후 -- 해갈것
                      console.log("readyUserCount : " + readyUserCount);

                      // 동기화
                      if (modifiedMemberResponse == null) {
                          // 수정할 멤버의 정보가 없음
                          if (modifiedMemberListItem != null) {
                              // list-item 은 존재함 -> 삭제
                              modifiedMemberListItem.remove();
                          }
                      } else {
                          // 수정할 멤버의 정보가 있음 -> newListItem 생성
                          let newMemberListItem = createMemberListItem(modifiedMemberResponse);
                          if (modifiedMemberListItem == null) {
                              // 수정할 멤버의 정보 있음, list-item 없음, -> 새 list-item 추가
                              memberList.appendChild(newMemberListItem);
                          } else {
                              // 수정할 멤버의 정보 있음, list-item 있음 -> 새 list-item 으로 교체
                              modifiedMemberListItem.replaceWith(newMemberListItem);
                          }
                      }
                  });
          } // syncMemberList()

          /**
           * 수정할 멤버의 정보를 받아서, 새로운 list-item 을 생성한다.
           * @param modifiedMemberResponse : 서버로 부터 받은 수정할 멤버의 정보 Object
           */
          function createMemberListItem(modifiedMemberResponse) {
              let newMemberListItem = document.createElement('li');
              newMemberListItem.classList.add('list-group-item', 'member-list-item');
              newMemberListItem.dataset.userid = modifiedMemberResponse.userId;

              let memberUsername = document.createElement('span');
              memberUsername.classList.add('member-username');
              memberUsername.textContent = modifiedMemberResponse.username;
              newMemberListItem.appendChild(memberUsername);

              let isRoomOwner = modifiedMemberResponse.isRoomOwner; // boolean
              if (isRoomOwner) {
                  let memberIsRoomOwner = document.createElement('span');
                  memberIsRoomOwner.classList.add('member-is-room-owner');
                  memberIsRoomOwner.textContent = '방장';
                  newMemberListItem.appendChild(memberIsRoomOwner);
              }

              let isMemberConnected = modifiedMemberResponse.isRoomConnected; // boolean
              let memberIsRoomConnected = document.createElement('span');
              memberIsRoomConnected.classList.add('member-is-room-connected');
              let connectedColorClass = isMemberConnected ? 'member-connected' : 'member-disconnected';
              memberIsRoomConnected.classList.add(connectedColorClass);
              memberIsRoomConnected.textContent = isMemberConnected ? '접속중' : "미접속";
              newMemberListItem.appendChild(memberIsRoomConnected);

              return newMemberListItem;
          }

          function changeReadyBtnStyle(isCurrentUserReady) {
              if (isCurrentUserReady == true) {
                  console.log('change isReady : ' + isCurrentUserReady)
                  // 준비하기(readyBtn) 클릭, 준비됨(unReadyBtn) 으로 변경
                  readyBtn.style.display = 'none';
                  unReadyBtn.style.display = 'block';
              } else {
                  // 준비됨(unReadyBtn) 클릭, 준비하기(readyBTn) 로 변경
                  readyBtn.style.display = 'block';
                  unReadyBtn.style.display = 'none';
              }
          }

          /**
           * 모든 #menuBar 내부 버튼 비활성화
           */
          function disableAllMenuBtnExceptMemberList() {
              document.querySelectorAll('#menuBar button').forEach(function (item) {
                  item.disabled = true;
              });
              memberListBtn.disabled = false;
          }

          /**
           * 모든 #menuBar 내부 버튼 활성화
           */
          function enableAllMenuBtn() {
              document.querySelectorAll('#menuBar button').forEach(function (item) {
                  item.disabled = false;
              });
          }


      }); // DOMContentLoaded

  </script>
</head>
<body>
<div class="container">

  <div id="roomHeader">
    <h2 th:text="${chatRoom.getName()}">RoomName</h2>
  </div>

  <hr>

  <div id="roomInfo" th:data-roomid="${chatRoom.id}">
    <!--    <span id="roomId" th:text="|id ${chatRoom.id}|" th:data-roomid="${chatRoom.id}">roomId</span>-->
    <!--    <span id="roomName" th:text="|name ${chatRoom.getName}|">roomName</span>-->
    <span id="roomType" th:text="|${chatRoom.getType().roomTypeName}|">roomType</span>
    <span id="infoGptActivated"></span>
    <span id="infoGptOwner"></span>
  </div>

  <hr>

  <!-- Modal -->
  <div class="modal fade" id="memberListModal" tabindex="-1" aria-labelledby="memberListModal" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h1 class="modal-title fs-5" id="memberListModalLabel">멤버 정보</h1>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>

        <div class="modal-body">
          <ul id="memberList" class="list-group list-group-flush">
          </ul>
        </div>

        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
        </div>
        </form>

      </div>
    </div>
  </div>

  <div id="menuContainer">
    <div id="menuBar" class="input-group">
      <button id="memberListBtn" type="button" class="btn btn-outline-success" data-bs-toggle="modal"
              data-bs-target="#memberListModal">
        멤버 정보
      </button>
      <button id="readyBtn" class="btn btn-outline-primary changeReadyBtn" data-toready="true">준비하기</button>
      <button id="unReadyBtn" class="btn btn-outline-info changeReadyBtn" data-toready="false">준비됨</button>
      <button id="startBtn" class="btn btn-outline-secondary" disabled>게임시작</button>
      <button id="unSubscribeBtn" class="btn btn-outline-danger" disabled='true'>Unsubscribe</button>
    </div>
  </div>

  <hr>

  <div id="conversationBox" class="card">
    <div id="conversationWrapper" class="card-body">
      <ul id="conversationList" class="list-group">
        <!-- Messages will be dynamically added here -->
      </ul>
    </div>
  </div>

  <div id="inputStatusBox">
    <p id="inputStatus">대기중</p>
  </div>
  <form id="conversationInput" class="input-group" sec:authorize="isAuthenticated()">
    <div class="input-group">
      <input type="text" id="blockSubmit" style="display: none"/>
      <input type="text" id="contentInput" class="form-control" placeholder="채팅 메시지 입력" value=""/>
      <input type="hidden" id="usernameInput" th:value="${#authentication.name}"/>
      <input type="hidden" id="order" value="0"/>
      <input type="hidden" id="userId" th:value="${#authentication.principal.id}">
      <div class="input-group-append">
        <button type="button" id="sendMessageBtn" class="btn btn-outline-primary">보내기</button>
      </div>
      <div class="input-group-append">
        <button type="button" id="sendGptMessageBtn" class="btn btn-outline-success">질문하기</button>
      </div>
    </div>
  </form>

</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ENjdO4Dr2bkBIFxQpeoTz1HIcje39Wm4jDKdf19U8gI4ddQ3GYNS7NTKfAdVQSZe"
        crossorigin="anonymous"></script>
</body>
</html>
